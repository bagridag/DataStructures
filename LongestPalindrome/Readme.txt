If the first element is equal to the last element of the string, increment the counter that counts from the start of the list(“i”)  by one and decrement the counter that counts backwards(“j”)  from the end of the list. And while they are equal, for ex: if s[i]=s[j] and s[i+1]= s[j-1] etc. store the elements in the subsequence array. When they are not equal, if the length of the longest palindromic subsequence btw.  i, j-1 is greater than the length of the longest palindromic subsequence btw. i+1 and j, decrement “j” by one while keeping “i” constant. If it is smaller than the other subsequence, increment “i” by one while keeping “j” constant. Keep on looping through that until i becomes equal to j. That means the counters reached an end position, and add that character at the end of the subsequence. Since the first half of the characters are in the other half- in the subsequence palindrome- i printed the reverse array and to avoid the element at which i= j to be written more than once, reverse array’s elements were printed starting from the position “1” instead of “0”.   